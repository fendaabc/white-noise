### **文档一：新功能说明文档 (面向产品和用户)**

# **功能详解**

我将为您完整地、详细地阐述一遍我对新版本“白噪音”应用的最终设想。这个设想融合了我们之前讨论的所有创意，旨在打造一个既实用又充满趣味和个性化的产品。

### **新版本应用核心设想：双面人生，声临其境**

新版本的核心理念是“**双模式体验**”。我们不再局限于单一的放松场景，而是为用户提供两种截然不同、可以一键切换的声音世界，满足他们在不同心境下的需求。

#### **模式一：常规放松模式 (The Classic Experience)**

这便是您应用当前的核心功能，我们将它保留并定义为“常规模式”。它是用户寻求专注、放松和睡眠时的首选。

* **主题**: 自然、平和、舒适。
* **界面**: 维持现有简洁、优雅的UI设计，以动态的自然风光（如海洋、森林、星空）为背景。
* **核心功能**:
    * **多音效叠加**: 用户可以自由组合多种声音，创造自己独特的环境音。
    * **音量独立调节**: (可考虑的未来增强) 每个声音都可以有自己独立的音量控制。
    * **定时关闭**: 用户可以设定播放时长，到点自动关闭，安心入睡。
* **白噪音类型 (维持现有)**:
    * **🌊 海浪声**: 连绵不绝的海浪，适合冥想和放松。
    * **🔥 篝火声**: 木柴燃烧的噼啪声，带来温暖和安全感。
    * **🌲 森林声**: 鸟语、风声和树叶的沙沙声，仿佛置身林间。
    * **☕ 咖啡厅**: 轻柔的背景人声、咖啡机和杯碟碰撞声，适合需要“人气”陪伴的工作学习。
    * **🌧️ 雨声**: 不同强度的雨滴声，从淅沥小雨到滂沱大雨，是经典的助眠声音。
    * **💨 风声**: 从轻柔的微风到呼啸的山风。
    * **🎧 白噪音/粉红噪音**: 纯粹的频率声，有效屏蔽干扰。

#### **模式二：“学霸/学渣”模式 (The Nostalgic Experience)**

这是新版本的亮点和核心创意。它并非为了真正的“放松”，而是旨在创造一种**充满怀旧、趣味、甚至带点“魔性”的沉浸式校园体验**。

* **主题**: 怀旧、校园、反差萌。
* **界面**: 模式切换后，背景会变为模糊的教室、黑板、操场跑道等校园主题图片。音效图标和整体色调也会变得更有趣、更富有个性。
* **核心功能**: 所有常规模式下的核心功能（多音效叠加、音量调节、定时关闭）在这里 **完全适用**。
* **预设白噪音类型 (精心设计，充满回忆杀)**:

| 分类 | 音效名称 | 建议图标 | 声音内容描述 |
| :--- | :--- | :--- | :--- |
| **课堂宇宙** | **班主任** | 👨‍🏫 / 👩‍🏫 | 循环播放经典语录：“整栋楼就你们班最吵！”、“看我干嘛？我脸上有答案？”、“体育老师今天有事，这节课上数学！”等。 |
| | **数学老师** | 📐 | 带有粉笔在黑板上“吱吱嘎嘎”的声音，夹杂着“这又是一道送分题！”、“看懂了吗？好，我们看下一题。” |
| | **语文老师** | 📖 | 富有感情地朗读课文的声音，例如“全文背诵！”，背景伴随着同学小声接下句的声音。 |
| | **英语老师** | 🔤 | 标准的课堂跟读，“OK, class. Read after me... Apple!”，以及磁带录音机略带杂音的播放声。 |
| | **物理老师** | ⚛️ | 讲解受力分析，或者带有电流“滋滋”声、小球碰撞声的实验课背景音。 |
| **校园生活** | **下课铃声** | 🔔 | 经典的校园电铃声，可以设置为短促、循环的提示音，也可以混合在其他声音里。 |
| | **课间操** | 🤸 | “时代在召唤”或“雏鹰起飞”的广播操音乐前奏，以及操场上嘈杂但充满活力的学生脚步声和口令声。 |
| | **运动会** | 🏃 | 发令枪响、裁判哨声、广播站播报、以及操场边震耳欲聋的“加油！加油！”呐喊声混合。 |
| | **晚自习** | ✍️ | 极其安静的背景下，偶尔传来翻书声、笔尖在纸上的沙沙声、远处同学的咳嗽声，以及老师巡视时皮鞋的脚步声。 |
| | **宿舍夜话** | 🤫 | 熄灯后，几个同学压低声音的窃窃私语和憋笑声，伴随着风扇的嗡嗡声。 |
| **摸鱼时光** | **小卖部** | 🏪 | 课间休息时拥挤的人声、撕开零食包装袋的声音、以及“老板，拿瓶可乐！”的喊话声。 |
| | **游戏厅** | 🕹️ | （90年代怀旧）放学后的街机游戏厅里，拳皇、街霸等经典游戏的背景音乐和操作摇杆、按键的清脆声音。 |

### **新版本的两大“杀手锏”功能**

这两大功能将应用从一个“播放器”提升为一个“个性化创作平台”。

#### **1. 终极个性化：自定义你的“老师”**

这是整个“学霸/学渣模式”的灵魂。

* **功能描述**: 用户可以长按“学霸/学渣模式”中的 **任何一个** 音效图标（比如“班主任”），选择“自定义声音”选项。
* **实现方式**: 应用将调用手机系统的文件管理器，让用户从本地存储中选择一个音频文件（如MP3, M4A, WAV等）。
* **用户体验**: 一旦设定，这个“班主任”音效播放的就是用户自己上传的音频。这可以是**自己高中班主任的真实录音**，也可以是网上下载的任何有趣音频。应用会将此文件安全地保存在本地，用户可以随时播放或再次更换。

#### **2. 跨设备同步：你的专属记忆永不丢失**

为了让用户的个性化设置更有价值，我们提供可选的云同步功能。

* **功能描述**: 在设置界面，用户可以选择“云盘同步”功能。
* **实现方式**: 用户需要授权自己的云盘账户（如Google Drive, OneDrive或国内的阿里云盘等）。授权后，应用可以将所有已自定义的音频文件和配置信息，一键备份到云盘的一个专属文件夹内。
* **用户体验**: 当用户更换手机，或在平板等其他设备上使用时，只需再次授权同一个云盘账号，即可一键将所有“专属老师”和设置恢复到新设备上，无需重新上传和配置。这个功能是**完全可选的**，我们不强制用户使用，也不会存储用户的任何账号信息。

---

**总结一下**，新版本的完整设想是：一个拥有**双重性格**的应用。它可以是你在深夜里最宁静的陪伴（**常规模式**），也可以是你和朋友间分享乐趣、追忆青春的“时光机”（**学霸/学渣模式**）。而**自定义音频**和**云同步**功能，则将“独一无二”和“永久珍藏”这两个核心价值赋予了产品，使其不再是一个简单的工具，而是一个承载用户个人情感和记忆的平台。

# **新功能说明： “学霸/学渣”模式**

**版本**: 2.0
**日期**: 2025年8月26日

## 1\. 功能概述

“学霸/学渣模式”是白噪音应用的一个全新、充满趣味性的扩展功能。它旨在为用户提供一种新颖、个性化的环境音体验，与传统的放松型白噪音形成鲜明对比。用户可以一键切换到此模式，将环境音从“海浪”、“篝火”等自然声音，变为充满怀旧与趣味性的“课堂”主题声音，如“班主任的唠叨”、“数学老师的讲课声”等。

此功能最大的亮点在于其 **高度的可自定义性**。用户不仅可以收听我们预设的课堂音效，更可以**将任意音效（如“班主任”）替换为自己录制或下载的音频**。想象一下，用自己高中班主任的原声音频来打造一个“沉浸式”的学习（或“催眠”）环境，这将带来无与伦-比的个性化体验。

为了方便用户在不同设备间同步自己的创意，我们还引入了**可选的云盘同步功能**，让您的专属“课堂”可以随身携带。

## 2\. 核心特性

| 特性 | 详细说明 | 用户价值 |
| :--- | :--- | :--- |
| **一键模式切换** | 在应用主界面提供一个清晰的按钮，用户可以轻松地在“常规放松模式”和“学霸/学渣模式”之间切换。 | 提供了两种截然不同的使用场景，增加了应用的趣味性和可玩性，满足用户多样化的情感需求。 |
| **趣味课堂音效** | “学霸/学渣模式”下，提供一系列精心设计的、与校园和课堂相关的预设音效，如不同学科老师的讲课声、运动会、晚自习等。 | 营造一种怀旧、有趣、甚至有点“魔性”的氛围，容易在社交媒体上引发共鸣和分享。 |
| **个性化音频定制** | 用户可以选择“学霸/学渣模式”中的任意一个音效按钮（例如“班主任”），并从自己的手机上传一个本地音频文件（如MP3, M4A）来替换它。 | 功能的核心亮点。让每个用户都能创造出独一无二、与自己记忆深刻关联的环境音，实现真正的“个性化催眠”。 |
| **本地持久化存储** | 用户自定义的音频文件将被安全地保存在应用的本地空间中，即使重启应用或手机，配置也不会丢失。 | 保证了用户个性化设置的稳定性和可靠性，无需每次都重新上传。 |
| **（可选）云盘同步** | 用户可以选择授权自己的云盘服务。授权后，可以将所有自定义的音频一键上传到云盘的专属应用文件夹中，或从云盘一键恢复到任何新设备上。 | 解决了跨设备使用的问题，保护了用户的数字资产。用户更换手机后，也能轻松找回自己精心配置的“课堂”。 |
| **无缝的播放体验** | 无论是内置的音效还是用户自定义的音频，都支持与现有功能（如多音效叠加、音量调节、定时关闭）的无缝集成。 | 保证了新功能在体验上的一致性，用户无需学习新的操作逻辑。 |

## 3\. 用户故事 (User Stories)

  - **作为一名大学生**，我希望在期末复习时，能听到高中数学老师的讲课声，那种熟悉的感觉能让我更专注。我可以使用“自定义音频”功能，把我以前录下的老师讲课音频设置为“数学老师”的声音。

  - **作为一名上班族**，我想和朋友分享这个有趣的App。我可以切换到“学霸/学渣模式”，播放“班主任”的经典语录，这让我们都想起了自己的学生时代，非常有趣。

  - **作为一名长期用户**，我换了一部新手机。我希望我之前为每个“老师”精心挑选的音频不会丢失。我可以使用“云盘同步”功能，在新手机上登录我的云盘账号，一键就把所有设置都恢复了。

## 4\. 交互流程简述

1.  用户打开App，默认为“常规放松模式”。
2.  用户点击“切换模式”按钮，界面动画切换至“学霸/学渣模式”，音效列表更新为“班主任”、“数学老师”等。
3.  用户长按（或点击按钮旁的“编辑”图标）“班主任”按钮。
4.  App弹出操作菜单，选项包括“播放”、“设为自定义声音”。
5.  用户选择“设为自定义声音”，App调用系统文件选择器。
6.  用户从手机中选择一个音频文件（例如 `my_teacher.mp3`）。
7.  文件保存成功后，“班主任”按钮上出现一个“自定义”的角标。
8.  此后，用户点击“班主任”按钮，播放的就是 `my_teacher.mp3`。
9.  在设置菜单中，用户可以找到“云盘同步”选项，进行授权和数据同步操作。

-----

### **文档二：技术开发文档 (面向AI和开发者)**

# **技术开发文档：V2.0 “学霸/学渣模式”**

## 1\. 总体架构概述

本项目将从一个纯前端的Web应用，演进为一个基于 **Capacitor** 框架打包的跨平台（iOS & Android）移动应用。核心架构变更是引入了**原生能力调用**（特别是文件系统API）和**统一的本地音频播放引擎**。所有音频资源（内置HLS和用户自定义的标准格式音频）都将作为本地文件进行播放，以确保离线可用性和播放稳定性。

## 2\. 开发阶段与模块分解

### **阶段一：应用基础建设 (从Web到Mobile)**

**目标**: 将现有Web项目成功打包成可在iOS和Android模拟器/真机上运行的App。

#### **模块1.1: Capacitor集成**

  - **技术栈**: `@capacitor/core`, `@capacitor/cli`, `@capacitor/filesystem`, `@capacitor/preferences`
  - **任务**:
    1.  **环境准备**: 确保已安装Node.js, Xcode, 和 Android Studio。
    2.  **初始化**: 在项目根目录运行 `npx cap init [appName] [appId]`。
    3.  **平台添加**: 运行 `npx cap add ios` 和 `npx cap add android`。
    4.  **构建与同步**: 每次Web代码更新后，需运行 `npm run build` (或等效的打包命令) 和 `npx cap sync`。
    5.  **运行**: 通过 `npx cap open ios` 或 `npx cap open android` 在对应IDE中打开原生项目并运行。

#### **模块1.2: 本地资源路径管理**

  - **挑战**: Web中的相对路径 (`audio.hls/...`) 需要能被App正确访问。
  - **方案**:
    1.  确保所有内置的HLS音频文件夹 (`audio.hls/*`) 都位于被Capacitor打包的Web目录内（通常是`www`或`dist`）。
    2.  在 `main.js` 的 `soundConfig` 中，路径保持为相对路径。Capacitor的WebView能够解析这些路径指向App包内的资源。
    3.  **代码示例 (`main.js`)**:
        ```javascript
        const soundConfig = {
          waves: { path: "audio.hls/waves/playlist.m3u8", name: "海浪声", icon: "🌊", type: 'hls' },
          // ... 为所有预设音效添加 type: 'hls'
        };
        ```

### **阶段二：核心功能实现**

**目标**: 实现模式切换、UI动态更新、以及处理和播放用户自定义音频的核心逻辑。

#### **模块2.1: 状态管理扩展 (`main.js`)**

  - **任务**:
    1.  扩展 `appState` 对象以管理模式和自定义声音。
    2.  实现配置的本地持久化。
  - **代码示例 (`main.js`)**:
    ```javascript
    import { Preferences } from '@capacitor/preferences';

    let appState = {
        isPlaying: false,
        playingSounds: new Set(),
        volume: 70,
        currentMode: 'normal', // 'normal' or 'campus'
        customSounds: {} // 持久化对象
    };

    // customSounds 结构:
    // {
    //   "headTeacher": { "type": "local", "path": "capacitor-file://...", "fileName": "..." },
    //   "mathTeacher": { "type": "default" }
    // }

    async function saveCustomSounds() {
        await Preferences.set({
            key: 'customSoundsConfig',
            value: JSON.stringify(appState.customSounds),
        });
    }

    async function loadCustomSounds() {
        const { value } = await Preferences.get({ key: 'customSoundsConfig' });
        if (value) {
            appState.customSounds = JSON.parse(value);
        }
    }
    ```

#### **模块2.2: 本地文件处理 (`main.js`)**

  - **技术栈**: `@capacitor/filesystem`
  - **任务**:
    1.  提供一个隐藏的 `<input type="file" id="audio-picker" accept="audio/*">`。
    2.  当用户选择文件后，读取该文件并将其复制到应用的永久存储区。
  - **代码示例 (`main.js`)**:
    ```javascript
    import { Filesystem, Directory } from '@capacitor/filesystem';

    // 假设要为 'headTeacher' 设置自定义声音
    async function setCustomSound(soundKey, file) {
        const fileName = `${soundKey}_${Date.now()}.${file.name.split('.').pop()}`;

        // 为了读取文件内容，我们需要将其转换为 base64
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = async () => {
            const base64Data = reader.result.split(',')[1];

            // 将文件写入应用的永久数据目录
            const writeFileResult = await Filesystem.writeFile({
                path: `custom_sounds/${fileName}`,
                data: base64Data,
                directory: Directory.Data, // 应用的私有、永久目录
            });

            // 更新状态并保存
            appState.customSounds[soundKey] = {
                type: 'local',
                path: writeFileResult.uri, // 获取到永久的、可播放的URI
                fileName: file.name
            };
            await saveCustomSounds();
            
            // 此处应有UI更新逻辑
        };
    }
    ```

#### **模块2.3: 音频引擎重构 (`UniversalAudioManager.js`)**

  - **目标**: 创建一个能统一处理本地HLS和本地标准音频的播放器。
  - **任务**:
    1.  重构 `HlsAudioManager.js` 为 `UniversalAudioManager.js`。
    2.  实现一个调度逻辑，根据音源类型选择不同的加载方式。
  - **核心代码 (`UniversalAudioManager.js`)**:
    ```javascript
    class UniversalAudioManager {
        constructor() {
            this.audioElements = new Map();
            this.hlsPlayers = new Map();
            this.activeSources = new Map();
            // ...
        }

        getSoundInfo(soundName) {
            const customSound = appState.customSounds[soundName];
            if (customSound && customSound.type === 'local') {
                return { path: customSound.path, type: 'standard' };
            }

            const activeConfig = appState.currentMode === 'normal' ? soundConfig : campusSoundConfig;
            const defaultConfig = activeConfig[soundName];
            if (defaultConfig) {
                return { path: defaultConfig.path, type: 'hls' };
            }
            return null;
        }

        async playSound(soundName, volume) {
            const soundInfo = this.getSoundInfo(soundName);
            if (!soundInfo) return false;

            let audio = this.audioElements.get(soundName);
            if (!audio) {
                audio = new Audio();
                audio.loop = true;
                this.audioElements.set(soundName, audio);
            }

            // --- 调度逻辑 ---
            if (soundInfo.type === 'hls') {
                // 如果需要，加载HLS
                if (!this.hlsPlayers.has(soundName)) {
                    const hls = new Hls();
                    hls.loadSource(soundInfo.path);
                    hls.attachMedia(audio);
                    this.hlsPlayers.set(soundName, hls);
                }
            } else { // 'standard'
                // 确保移除可能存在的HLS实例
                if (this.hlsPlayers.has(soundName)) {
                    this.hlsPlayers.get(soundName).destroy();
                    this.hlsPlayers.delete(soundName);
                }
                // 直接设置src
                if (audio.src !== soundInfo.path) {
                    audio.src = soundInfo.path;
                }
            }
            
            audio.volume = volume;
            await audio.play();
            this.activeSources.set(soundName, { audio });
            return true;
        }

        stopSound(soundName) {
            if (this.activeSources.has(soundName)) {
                const { audio } = this.activeSources.get(soundName);
                audio.pause();
                audio.currentTime = 0;
                this.activeSources.delete(soundName);
            }
        }
    }
    ```

### **阶段三：云盘同步功能**

**目标**: 实现自定义音频配置和文件的可选云端备份与恢复。

#### **模块3.1: 云盘SDK与授权**

  - **技术选型**: 推荐使用对JS支持良好且有官方SDK的服务，如 **Google Drive API** 或国内云服务商的JS-SDK。
  - **任务**:
    1.  集成SDK，并实现OAuth 2.0授权流程。可以使用 `capacitor-oauth2` 等社区插件简化流程。
    2.  安全地存储 `access_token` 和 `refresh_token` (使用 `@capacitor/preferences`)。
    3.  在云盘中为本应用创建唯一的根目录，如 `/App/WhiteNoiseCustomSounds/`。

#### **模块3.2: 文件上传与下载**

  - **上传逻辑**:
    1.  遍历 `appState.customSounds` 中所有 `type: 'local'` 的条目。
    2.  使用 `Filesystem.readFile` 读取本地文件的base64数据。
    3.  调用云盘SDK的上传接口，将文件上传至指定目录。
  - **下载/恢复逻辑**:
    1.  调用云盘SDK的 `list` 接口，获取云端目录下的所有音频文件。
    2.  为每个文件，调用 `download` 接口。
    3.  将下载的数据流（通常是base64）使用 `Filesystem.writeFile` 写回到本地的 `custom_sounds` 目录中。
    4.  更新 `appState.customSounds` 中的本地路径(`path`)并保存配置。